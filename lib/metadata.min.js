import fs from"fs/promises";import path from"path";import{fileURLToPath}from"url";import{getOrgId}from"./runcontext.js";import{log}from"./logger.js";const __filename=fileURLToPath(import.meta.url),__dirname=path.dirname(__filename),DEFAULT_META_DIR=path.resolve(process.cwd(),"meta-data");async function ensureDir(e){await fs.mkdir(e,{recursive:!0})}async function saveJSON(e,t){await fs.writeFile(e,JSON.stringify(t,null,2),"utf8")}async function loadJSON(e){const t=await fs.readFile(e,"utf8");return JSON.parse(t)}async function fileExists(e){try{return await fs.access(e),!0}catch{return!1}}async function resolveOrgId(e,t){if(t&&String(t).trim())return String(t).trim();const r=await e.identity(),a=r?.organization_id||r?.organizationId||r?.organization?.id;if(!a)throw new Error("metadata.js: Unable to resolve organization Id from connection identity.");return a}async function resolveOrgMetaDir(e,{metaDir:t=DEFAULT_META_DIR,orgId:r}={}){const a=await resolveOrgId(e,r),n=path.join(path.resolve(t),a);return await ensureDir(n),{orgId:a,orgDir:n}}export async function fetchObjectDescribe(e,t){const r=await e.sobject(t).describe();return{name:r.name,label:r.label,custom:r.custom,createable:r.createable,updateable:r.updateable,keyPrefix:r.keyPrefix,fields:(r.fields||[]).map((e=>({name:e.name,label:e.label,type:e.type,nillable:e.nillable,createable:e.createable,updateable:e.updateable,unique:e.unique,defaultedOnCreate:e.defaultedOnCreate,length:e.length,precision:e.precision,scale:e.scale,referenceTo:e.referenceTo||[],picklistValues:(e.picklistValues||[]).map((e=>({value:e.value,active:e.active}))),calculated:e.calculated,inlineHelpText:e.inlineHelpText||null})))}}export async function snapshotOrgMetadata(e,{objectNames:t,metaDir:r=DEFAULT_META_DIR,orgId:a,forceRefresh:n=!1,concurrency:o=1}={}){if(!Array.isArray(t)||0===t.length)throw new Error("snapshotOrgMetadata: 'objectNames' must be a non-empty array.");const{orgId:i,orgDir:s}=await resolveOrgMetaDir(e,{metaDir:r,orgId:a}),c=Array.from(new Set(t.map((e=>String(e).trim())).filter(Boolean))).sort();await saveJSON(path.join(s,"objects.json"),c);const l=c.slice(),d=Math.max(1,Math.min(o,8)),f=new Array(d).fill(0).map((async()=>{for(;l.length;){const t=l.shift(),r=path.join(s,`${t}.json`);if(!n&&await fileExists(r))continue;const a=await fetchObjectDescribe(e,t);await saveJSON(r,a)}}));return await Promise.all(f),{metaDir:s,orgId:i,objects:c}}export async function loadObjectDescribe(e,t,{metaDir:r=DEFAULT_META_DIR,orgId:a}={}){const{orgDir:n}=await resolveOrgMetaDir(e,{metaDir:r,orgId:a});return loadJSON(path.join(n,`${t}.json`))}export async function loadCachedObjectList(e,{metaDir:t=DEFAULT_META_DIR,orgId:r}={}){const{orgDir:a}=await resolveOrgMetaDir(e,{metaDir:t,orgId:r});return loadJSON(path.join(a,"objects.json"))}export async function loadFieldMap(e,t,{metaDir:r=DEFAULT_META_DIR,orgId:a}={}){const n=await loadObjectDescribe(e,t,{metaDir:r,orgId:a}),o=new Map;for(const e of n.fields||[])o.set(String(e.name).toLowerCase(),e);return o}export function resolveOrgDir({metaDir:e=DEFAULT_META_DIR}={}){const t=path.resolve(e),r=getOrgId().trim();return path.join(t,r)}export async function ensureObjectMetadataAvailable(e,t={}){const r=resolveOrgDir(t),a=path.join(r,"objects.json"),n=path.join(r,`${e}.json`),o=await fileExists(a),i=await fileExists(n);if(!o||!i){t.metaDir;const r=t.orgId||process.env.SF_ORG_ID||"<unset>",s=[];throw o||s.push(`'${path.relative(process.cwd(),a)}'`),i||s.push(`'${path.relative(process.cwd(),n)}'`),new Error(`[metadata-validator] Missing metadata file(s) for ${e}: ${s.join(", ")}.\nExpected under meta-data/${r}/. Run a metadata snapshot first (e.g., REFRESH_METADATA=true).`)}return n}export async function loadObjectDescribeFromCache(e,t={}){const r=resolveOrgDir(t),a=path.join(r,`${e}.json`),n=await fs.readFile(a,"utf8");return JSON.parse(n)}export function toFieldMap(e){const t=new Map;for(const r of e.fields||[])t.set(String(r.name).toLowerCase(),r);return t}export function validateRecordAgainstFields(e,t,r,{operation:a="insert"}={}){const n=[],o="insert"===a||"upsert"===a;for(const a of Object.keys(t)){if(!a||"attributes"===a)continue;const t=r.get(a.toLowerCase());t?(o&&"Id"!==a&&!1===t.createable&&n.push({level:"error",code:"FIELD_NOT_CREATEABLE",message:`Field '${a}' on ${e} is not createable.`}),o||"Id"===a||!1!==t.updateable||n.push({level:"error",code:"FIELD_NOT_UPDATEABLE",message:`Field '${a}' on ${e} is not updateable.`})):n.push({level:"error",code:"FIELD_MISSING",message:`Unknown field '${a}' on ${e}.`})}return n}export function validateBatch(e,t,r,{operation:a="insert"}={}){const n=[];for(let o=0;o<t.length;o++){const i=validateRecordAgainstFields(e,t[o]||{},r,{operation:a});i.forEach((e=>{e.recordIndex=o})),n.push(...i)}const o=n.filter((e=>"error"===e.level));if(o.length){const t=o.slice(0,10).map((e=>`#${e.recordIndex+1} ${e.code}: ${e.message}`)).join("\n  - ");throw new Error(`[metadata-validator] ${e}: ${o.length} field validation error(s).\n  - ${t}\nFix mapping/data or refresh metadata cache.`)}return{problems:n}}export function pruneRecordFields(e,t,r,{operation:a="insert",pruneUnknown:n=!0,pruneNotWritable:o=!0}={}){const i="insert"===a||"upsert"===a,s=new Map,c=new Map,l=new Map,d=t.map((e=>{const t={};for(const[a,d]of Object.entries(e||{})){if("attributes"===a){t[a]=d;continue}const e=r.get(String(a).toLowerCase());if(e){if(o&&"Id"!==a){if(i&&!1===e.createable){c.set(a,1+(c.get(a)||0));continue}if(!i&&!1===e.updateable){l.set(a,1+(l.get(a)||0));continue}}t[a]=d}else n?s.set(a,1+(s.get(a)||0)):t[a]=d}return t})),f=e=>Array.from(e.entries()).map((([e,t])=>`${e}Ã—${t}`)).join(", ");return s.size&&log.info(e,`ðŸª“ Pruned unknown fields (total ${t.length} record(s)): ${f(s)}`),c.size&&i&&log.info(e,`ðŸª“ Pruned non-createable fields for ${a}: ${f(c)}`),l.size&&!i&&log.info(e,`ðŸª“ Pruned non-updateable fields for ${a}: ${f(l)}`),d}