import fs from"fs/promises";import path from"path";import{fileURLToPath}from"url";import{getOrgId}from"./runcontext.js";import{log}from"./utils/logger.js";const __filename=fileURLToPath(import.meta.url),__dirname=path.dirname(__filename),DEFAULT_META_DIR=path.resolve(process.cwd(),"meta-data");async function ensureDir(e){await fs.mkdir(e,{recursive:!0})}async function saveJSON(e,t){await fs.writeFile(e,JSON.stringify(t,null,2),"utf8")}async function loadJSON(e){const t=await fs.readFile(e,"utf8");return JSON.parse(t)}async function fileExists(e){try{return await fs.access(e),!0}catch{return!1}}async function resolveOrgId(e,t){if(t&&String(t).trim())return String(t).trim();const r=await e.identity(),a=r?.organization_id||r?.organizationId||r?.organization?.id;if(!a)throw new Error("metadata.js: Unable to resolve organization Id from connection identity.");return a}async function resolveOrgMetaDir(e,{metaDir:t=DEFAULT_META_DIR,orgId:r}={}){const a=await resolveOrgId(e,r),o=path.join(path.resolve(t),a);return await ensureDir(o),{orgId:a,orgDir:o}}export async function fetchObjectDescribe(e,t){try{const r=await e.sobject(t).describe();return{success:!0,name:r.name,label:r.label,custom:r.custom,createable:r.createable,updateable:r.updateable,keyPrefix:r.keyPrefix,fields:(r.fields||[]).map((e=>({name:e.name,label:e.label,type:e.type,nillable:e.nillable,createable:e.createable,updateable:e.updateable,unique:e.unique,defaultedOnCreate:e.defaultedOnCreate,length:e.length,precision:e.precision,scale:e.scale,referenceTo:e.referenceTo||[],picklistValues:(e.picklistValues||[]).map((e=>({value:e.value,active:e.active}))),calculated:e.calculated,inlineHelpText:e.inlineHelpText||null})))}}catch(e){return console.error(`Failed to describe object: ${t}`,e.message),{success:!1,error:`Failed to describe object: ${t}`}}}export async function snapshotOrgMetadata(e,{objectNames:t,metaDir:r=DEFAULT_META_DIR,orgId:a,forceRefresh:o=!1,concurrency:n=1}={}){if(!Array.isArray(t)||0===t.length)throw new Error("snapshotOrgMetadata: 'objectNames' must be a non-empty array.");const{orgId:i,orgDir:s}=await resolveOrgMetaDir(e,{metaDir:r,orgId:a}),c=Array.from(new Set(t.map((e=>String(e).trim())).filter(Boolean))).sort();await saveJSON(path.join(s,"objects.json"),c);let l=[];const d=c.slice(),u=Math.max(1,Math.min(n,8)),f=new Array(u).fill(0).map((async()=>{for(;d.length;){const t=d.shift(),r=path.join(s,`${t}.json`);if(!o&&await fileExists(r))continue;const a=await fetchObjectDescribe(e,t);a.success?await saveJSON(r,a):l.push(t)}}));return await Promise.all(f),{metaDir:s,orgId:i,objects:c,unavailableObjects:l}}export async function loadObjectDescribe(e,t,{metaDir:r=DEFAULT_META_DIR,orgId:a}={}){const{orgDir:o}=await resolveOrgMetaDir(e,{metaDir:r,orgId:a});return loadJSON(path.join(o,`${t}.json`))}export async function loadCachedObjectList(e,{metaDir:t=DEFAULT_META_DIR,orgId:r}={}){const{orgDir:a}=await resolveOrgMetaDir(e,{metaDir:t,orgId:r});return loadJSON(path.join(a,"objects.json"))}export async function loadFieldMap(e,t,{metaDir:r=DEFAULT_META_DIR,orgId:a}={}){const o=await loadObjectDescribe(e,t,{metaDir:r,orgId:a}),n=new Map;for(const e of o.fields||[])n.set(String(e.name).toLowerCase(),e);return n}export function resolveOrgDir({metaDir:e=DEFAULT_META_DIR}={}){const t=path.resolve(e),r=getOrgId().trim();return path.join(t,r)}export async function ensureObjectMetadataAvailable(e,t={}){const r=resolveOrgDir(t),a=path.join(r,"objects.json"),o=path.join(r,`${e}.json`),n=await fileExists(a),i=await fileExists(o);if(!n||!i){t.metaDir;const r=t.orgId||process.env.SF_ORG_ID||"<unset>",s=[];throw n||s.push(`'${path.relative(process.cwd(),a)}'`),i||s.push(`'${path.relative(process.cwd(),o)}'`),new Error(`[metadata-validator] Missing metadata file(s) for ${e}: ${s.join(", ")}.\nExpected under meta-data/${r}/. Run a metadata snapshot first (e.g., REFRESH_METADATA=true).`)}return o}export async function loadObjectDescribeFromCache(e,t={}){const r=resolveOrgDir(t),a=path.join(r,`${e}.json`),o=await fs.readFile(a,"utf8");return JSON.parse(o)}export function toFieldMap(e){const t=new Map;for(const r of e.fields||[])t.set(String(r.name).toLowerCase(),r);return t}export function validateRecordAgainstFields(e,t,r,{operation:a="insert"}={}){const o=[],n="insert"===a||"upsert"===a;for(const a of Object.keys(t)){if(!a||"attributes"===a)continue;const t=r.get(a.toLowerCase());t?(n&&"Id"!==a&&!1===t.createable&&o.push({level:"error",code:"FIELD_NOT_CREATEABLE",message:`Field '${a}' on ${e} is not createable.`}),n||"Id"===a||!1!==t.updateable||o.push({level:"error",code:"FIELD_NOT_UPDATEABLE",message:`Field '${a}' on ${e} is not updateable.`})):o.push({level:"error",code:"FIELD_MISSING",message:`Unknown field '${a}' on ${e}.`})}return o}export function validateBatch(e,t,r,{operation:a="insert"}={}){const o=[];for(let n=0;n<t.length;n++){const i=validateRecordAgainstFields(e,t[n]||{},r,{operation:a});i.forEach((e=>{e.recordIndex=n})),o.push(...i)}const n=o.filter((e=>"error"===e.level));if(n.length){const t=n.slice(0,10).map((e=>`#${e.recordIndex+1} ${e.code}: ${e.message}`)).join("\n  - ");throw new Error(`[metadata-validator] ${e}: ${n.length} field validation error(s).\n  - ${t}\nFix mapping/data or refresh metadata cache.`)}return{problems:o}}export function pruneRecordFields(e,t,r,{operation:a="insert",pruneUnknown:o=!0,pruneNotWritable:n=!0}={}){const i="insert"===a||"upsert"===a,s=new Map,c=new Map,l=new Map,d=t.map((e=>{const t={};for(const[a,d]of Object.entries(e||{})){if("attributes"===a){t[a]=d;continue}const e=r.get(String(a).toLowerCase());if(e){if(n&&"Id"!==a){if(i&&!1===e.createable){c.set(a,1+(c.get(a)||0));continue}if(!i&&!1===e.updateable){l.set(a,1+(l.get(a)||0));continue}}t[a]=d}else o?s.set(a,1+(s.get(a)||0)):t[a]=d}return t})),u=e=>Array.from(e.entries()).map((([e,t])=>`${e} Ã— ${t}`)).join(", ");return s.size&&log.info(e,`ðŸª“ Pruned unknown fields (total ${t.length} record(s)): ${u(s)}`),c.size&&i&&log.info(e,`ðŸª“ Pruned non-createable fields for ${a}: ${u(c)}`),l.size&&!i&&log.info(e,`ðŸª“ Pruned non-updateable fields for ${a}: ${u(l)}`),d}