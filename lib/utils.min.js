function get(e,t){return t.split(".").reduce(((e,t)=>e?e[t]:void 0),e)}function set(e,t,o){const n=t.split(".");let s=e;for(let e=0;e<n.length-1;e++){const t=n[e];null!=s[t]&&"object"==typeof s[t]||(s[t]={}),s=s[t]}s[n[n.length-1]]=o}function del(e,t){const o=t.split(".");let n=e;for(let e=0;e<o.length-1;e++){const t=o[e];if(null==n[t])return;n=n[t]}delete n[o[o.length-1]]}export function shapeRecord(e,t){const o={...e};for(const e of t?.shape?.removeFields||[])del(o,e);const n=t?.shape?.defaults||{};for(const[e,t]of Object.entries(n))void 0===get(o,e)&&set(o,e,t);const s=t?.shape?.fieldMap||{};for(const[e,t]of Object.entries(s))e!==t&&void 0!==get(o,e)&&(set(o,t,get(o,e)),del(o,e));return o}function applyRecordTemplates(e,t){return"string"!=typeof e?e:e.replace(/\$\{([^}]+)\}/g,((e,o)=>{const n=get(t,o.trim());return null==n?"":String(n)}))}export function applyTransforms(e,t=[]){let o={...e};for(const e of t){const{op:t}=e||{};if(t)if("assign"===t){const t=applyRecordTemplates(e.expr,o);set(o,e.out,t)}else if("copy"===t)set(o,e.out,get(o,e.from));else if("rename"===t){const t=get(o,e.from);void 0!==t&&(set(o,e.to,t),del(o,e.from))}else if("remove"===t)del(o,e.field);else if("coalesce"===t){const t=e.from||[];let n;for(const e of t){const t=get(o,e);if(null!=t&&""!==t){n=t;break}}void 0===n&&(n=e.default),set(o,e.out,n)}else if("concat"===t){const t=(e.parts||[]).map((e=>applyRecordTemplates(e,o)));set(o,e.out,t.join(""))}}return o}export function resolveReferences(e,t=[],o={}){const n={...e};for(const e of t){const{field:t,from:s,required:r}=e;if(!t||!s)continue;const l=applyRecordTemplates(s,n);let i;if(l.startsWith("idMaps.")){const e=l.match(/^idMaps\.([A-Za-z0-9_]+)\[['"]([^'"]+)['"]\]$/);if(e){console.log(JSON.stringify(o));const t=e[1],n=e[2];i=(o[t]||{})[n]}else i=get({idMaps:o},l)}else i=get(n,l),void 0===i&&(i=l);if(console.log(i),(null==i||""===i)&&r)throw new Error(`Missing required reference '${t}' from expression '${s}' (expanded: '${l}')`);null!=i&&""!==i&&set(n,t,i)}return n}export function assertRequiredFields(e,t=[],o="record"){for(const n of t){const t=get(e,n);if(null==t||""===t)throw new Error(`Validation failed: '${o}' missing required field '${n}'`)}}export function resolveConstantsDeep(e,t={}){const o=JSON.stringify(e).replace(/\$\{constants\.([^}]+)\}/g,((e,o)=>{const n=get(t,o);return null==n?"":String(n)}));return JSON.parse(o)}